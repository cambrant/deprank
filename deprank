#!/usr/bin/env python

import sys
import subprocess
from collections import Counter
from natsort import natsorted
from getpass import getuser

class Deprank:
    def __init__(self):
        self.printed_percentage = []
        self.dnf = False
        self.yum = False

    def output_percent_done(self, current, total):
        # Round the percentage of completed items down to the nearest 5 percent and
        # output that percentage if the percentage is divisible by 10 and if the
        # percentage has not been printed before.
        percent_done = int(float(current) / total * 100)

        if (percent_done - (percent_done % 5)) % 10 == 0:
            rounded_percentage = percent_done - (percent_done % 5)

            if rounded_percentage not in self.printed_percentage:
                self.printed_percentage.append(rounded_percentage)
                print "%d%% done" % rounded_percentage

    def cmd_exists(self, cmd):
        # Return True if the passed executable exists, False otherwise.
        return subprocess.call("type " + cmd, shell=True,
            stdout=subprocess.PIPE, stderr=subprocess.PIPE) == 0

    def get_package_info(self, files):
        # Get package information.

        package_name = ''
        package_info = ''
        packages = []

        file_count = len(files)
        files_done = 0
        for file_name in files:
            try:
                if self.dnf:
                    output = subprocess.check_output(['dnf', '-C', 'provides',
                        file_name], stderr=subprocess.STDOUT)

                    # Extract the full package name
                    package_name = output.split('\n')[1].split()[0]

                    # Remove the trailing architecture (".i686", etc)
                    package_name = '.'.join(package_name.split('.')[0:-1])

                    # Get the package info to extract the base package name.
                    package_info = subprocess.check_output(['dnf', '-C', 'info',
                        package_name], stderr=subprocess.STDOUT)
                elif self.yum:
                    output = subprocess.check_output(['yum', '-q', '-C', 'provides',
                        file_name], stderr=subprocess.STDOUT)

                    # Extract the full package name
                    package_name = output.split('\n')[0].split()[0]

                    # Remove the trailing architecture (".i686", etc)
                    package_name = '.'.join(package_name.split('.')[0:-1])

                    # Get the package info to extract the base package name.
                    package_info = subprocess.check_output(['yum', '-q', '-C',
                        'info', package_name],
                        stderr=subprocess.STDOUT)
            except IndexError:
                file_count -= 1
                continue
            except subprocess.CalledProcessError:
                # Could not get package name - discard the file and remove it from the
                # total count.
                file_count -= 1
                continue

            # Extract the base package name
            package_name = package_info.split('\n')[1].split()[-1]

            packages.append(package_name)
            files_done += 1

            self.output_percent_done(files_done, file_count)

        return packages

    def get_executable_file_list(self, directories):
        # Find all executables files in the specified directories.
        files = set()
        for directory in directories:
            command = ["find", directory, "-type", "f", "-perm", "/a+x", "-exec",
                "ldd", "{}", ";"]

            p = subprocess.Popen(command, stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE)
            output = p.communicate()[0]

            for line in output.split('\n'):
                if 'so' not in line:
                    continue

                # Remove leading file path.
                filename = line.split()[0]
                if '/' in filename:
                    filename = filename.split('/')[-1]

                files.add(filename)

        return files

    def find_package_manager(self):
        # Decide which package manager is available.
        if self.cmd_exists('dnf'):
            self.dnf = True
        elif self.cmd_exists('yum'):
            self.yum = True
        else:
            print 'Error: no package manager found!'
            return False

        return True

if __name__ == '__main__':
    deprank = Deprank()

    if getuser() != 'root':
        print 'Error: Not running as super user.'
        sys.exit(1)

    directories = ['/bin/', '/sbin/', '/usr/bin/', '/usr/sbin/', '/usr/local/bin/',
        '/usr/local/sbin/']

    if not deprank.find_package_manager():
        # No suitable package manager found. Exit.
        sys.exit(1)

    files = deprank.get_executable_file_list(directories)

    # This is a potentially long running function call and we want the user to
    # be able to abort properly.
    try:
        packages = deprank.get_package_info(files)
    except KeyboardInterrupt:
        print 'Aborted.'
        sys.exit(1)

    # Format and output package statistics.
    stats = []
    for f, c in Counter(packages).items():
        stats.append("%d\t%s" % (c, f))

    for package in natsorted(stats):
        print package
